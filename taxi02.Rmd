---
title: "Желтое такси в Нью-Йорке"
output:
  html_document: 
    toc: yes
  html_notebook: default
---

*Задача этого проекта — научиться предсказывать количество поездок в ближайшие часы в каждом районе Нью-Йорка. Для того, чтобы её решить, сырые данные необходимо агрегировать по часам и районам. Агрегированные данные будут представлять собой почасовые временные ряды с количествами поездок из каждого района. Похожие задачи возникают на практике, если вам необходимо спрогнозировать продажи большого количества товаров в большом количестве магазинов, объём снятия денег в сети банкоматов, посещаемость разных страниц сайта и т.д.*

# Неделя 2: Работа с геоданными {#week02}

### 0. Вступление и подготовка к работе {#w2s0}

Авторы проекта предложили использовать инструмент на выбор. Т.к. для меня это второй проект, то я решил его сделать на R. Ввиду того, что в специализации используется Python, я постарался снабдить код подробными комментариями, чтобы (при желании) было легче разобраться.

Для работы потребуются следующие библиотеки:

```{r libs, message=FALSE}
library(leaflet) # интерактивные карты
library(scales) # в помощь графикам
library(ggplot2) # графики
library(ggmap) # геоданные с Гугла
library(magrittr) # c'est ne pas une pipe
library(data.table) # работа с таблицами данных

# Sys.setlocale('LC_ALL','utf-8') # если неверно отображается кириллица
```

Информация о версиях библиотек и системе:

```{r versions}
sessionInfo()
```



### 1. Загрузите агрегированные данные о поездках в мае 2016 {#w2s1}

*Просуммируйте общее количество поездок такси из каждой географической зоны и посчитайте количество ячеек, из которых в мае не было совершено ни одной поездки.*

```{r load_dt_agg}
# загрузка
regions <- fread('data_in/regions.csv') # данные о регионах
dt_agg <- fread('data_out/2016_05.csv')

# суммирование по регионам
dt_month_regions <- dt_agg[, .(n = sum(n)), by = .(region)]

dt_month_regions[n == 0, .N]
```

Таким образом из 1283 регионов не было совершено ни одной поездки.

```{r NY}
##########################
# Константа с геоданными #
##########################

# Нью-Йорк вписан в прямоугольник от -74.25559 до -73.70001 градусов долготы и от 40.49612 до 40.91553 широты
NY <- list(lon = c(-74.25559, -73.70001), lat = c(40.49612, 40.91553))
NY$CELLS <- 50 # число ячеек по широте или долготе
NY$lon_step <- (NY$lon[2] - NY$lon[1]) / NY$CELLS # шаг по долготе
NY$lat_step <- (NY$lat[2] - NY$lat[1]) / NY$CELLS # шаг по широте
NY$lon_breaks <- seq(NY$lon[1], NY$lon[2], by = NY$lon_step) # границы регионов по долготе
NY$lat_breaks <- seq(NY$lat[1], NY$lat[2], by = NY$lat_step) # границы регионов по широте
```



### 2. Нарисуйте статическую карту Нью-Йорка {#w2s2}

*Поставьте на карте точку там, где находится Эмпайр-Стейт-Билдинг*.

Для отображения статических карт будем пользоваться пакетами `ggmap` и `ggplot2`.

```{r ESB, fig.asp=1, fig.width=6, fig.align='center', message=FALSE, warning=FALSE, cache=TRUE}
# координаты Empire State Building
# geocode('Empire State Building')

# введем координаты вручную
ESB <- list(lon = -73.98566, lat = 40.74844)

# скачиваем карту с маркером Эмпайр-Стейт-Билдинг
NY$map <- get_googlemap(c((NY$lon[1] + NY$lon[2]) / 2, 
                          (NY$lat[1] + NY$lat[2]) / 2),
                        zoom = 10, scale = 2,
                        size = c(640, 640),
                        markers = data.frame(lon = ESB$lon, lat = ESB$lat)
                        )

# отображаем и обрезаем карту по границам регионов
ggmap(NY$map, extent = 'device') +
    scale_x_continuous(limits = c(NY$lon[1], NY$lon[2])) +
    scale_y_continuous(limits = c(NY$lat[1], NY$lat[2])) + 
    labs(title = 'Карта Нью-Йорка', 
         subtitle = 'Эмпайр-Стейт-Билдинг отмечен маркером')
```



### 3. Визуализируйте данные о поездках {#w2s3}

*Поверх статической карты Нью-Йорка визуализируйте данные о поездках из каждой ячейки так, чтобы цветовая шкала, в которую вы окрашиваете каждую ячейку, показывала суммарное количество поездок такси из неё.*

Для начала посмотрим на распределение общего числа поездок по регионам за месяц. Для наглядности отобразим квадратный корень и логарифм этой величины:

```{r n_hists, fig.asp=1/2.5, fig.width=6, fig.align='center', message=FALSE, warning=FALSE}
# гистограмма n
dt_month_regions[n>0, .(region, n, sqrt_n = sqrt(n), log_n = log(n+1))] %>%
    melt(measure.vars = 2:4, id.vars = 1) %>%
    ggplot(aes(value, ..ncount..)) + 
    geom_histogram(bins = 15) + 
    facet_wrap(~variable, scales = 'free_x') + 
    labs(title = 'Гистограммы числа поездок', 
         subtitle = 'n, sqrt(n) и log(n+1)',
         x = 'Значение', y = 'Норм. частота') + 
    scale_y_continuous(breaks = c(0, 0.5, 1)) 
```

Очевидно, что если не преобразовывать число поездок, то практически вся карта будет раскрашена одноцветно, т.к. много нулей и маленьких значений. Поэтому для раскраски каждого региона воспользуемся логарифмическим преобразованием, а чтобы ячейки с небольшими значениями имели меньший цветовой вес, пусть прозрачность определяется корнем величины. Регионы с нулевым значением отрисовывать не будем. В этом случае, тепловая карта суммарного числав поездок будет выглядеть так:


```{r heatmap, fig.asp=1, fig.width=6, fig.align='center', message=FALSE, warning=FALSE, cache=TRUE}

# добавляем каждому региону его границы
dt_month_regions <- cbind(dt_month_regions, regions[, 2:5])

# скачиваем чистую карту
NY$map <- get_googlemap(c((NY$lon[1] + NY$lon[2]) / 2, 
                          (NY$lat[1] + NY$lat[2]) / 2),
                        zoom = 10, scale = 2,
                        size = c(640, 640)
                        )

# отображаем карту
ggmap(NY$map, extent = 'device') + 
    # рисуем квадратики, исключаем нулевые
    geom_rect(data = dt_month_regions[n > 0], 
              aes(xmin = west, xmax = east, ymin = south, ymax = north,
                  fill = log(n), alpha = sqrt(n)), 
              size = 0.1, color = 'gray60', inherit.aes = FALSE) +
    # обрезаем границы
    scale_x_continuous(limits = c(NY$lon[1], NY$lon[2])) +
    scale_y_continuous(limits = c(NY$lat[1], NY$lat[2])) +
    # заливка квадратиков
    scale_fill_distiller(palette = "OrRd", breaks = pretty_breaks(n = 6),
                         direction = 1) +
    # прозрачность квадратиков в зависимости от n
    scale_alpha(range=c(0.2, 0.5)) +
    # убираем легенды
    theme(legend.position="none") +
    # заголовок
    labs(title = 'Тепловая карта поездок за месяц')
```

На карту попали регионы, откуда поездок быть не может (бухты, река).



### 4. Вставьте интерактивную карту Нью-Йорка {#w2s4}

*Вставьте интерактивную карту Нью-Йорка — такую, которую можно прокручивать и увеличивать. Поставьте метку там, где находится статуя свободы.*

Для интерактивных карт воспользуемся пакетом `leaflet`. 

```{r SoL, message=FALSE, warning=FALSE, cache=TRUE}
# координаты Empire State Building
# geocode('Statue of Liberty')

# введем координаты вручную
SoL <- data.frame(lon = -74.0445, lat = 40.68925, name = 'Statue of Liberty')

# отображаем карту
leaflet(SoL, width = '100%') %>% addTiles() %>% 
    addMarkers(~lon, ~lat, popup = ~name) %>%
    setView(SoL$lon, SoL$lat, zoom = 12)
```



### 5. Отобразите среднее за месяц количество поездок {#w2s5}

*Нарисуйте на интерактивной карте Нью-Йорка ячейки так, чтобы их цвет показывал среднее за месяц количество поездок такси в час из этой зоны.*

Прежде всего необходимо рассчитать среднее количество поездок в час для каждого региона. Попробуем отобразить "горячую карту" так же, как и статичную карту. 

Рассчитаем прозрачность как корень из числа поездок и отмасштабируем множество этих значений на отрезок [0.2; 0.6]. 

Для получения цвета для каждой зоны, создадим палитру из 50 оттенков (как в предыдущей тепловой карте). Среднее число поездок из каждого региона прологарифмируем, а все множество логарифмов разобьем на 50 интервалов, сопоставив таким образом каждому логарифму среднего числа поездок свой оттенок из палитры. Для удобства добавим текст по клику для квадратиков, а для самой карты предусмотрим возможность отключения как слоя. По аналогии с предыдущей картой, не будем отображать регионы, среднее значение которых меньше 0.1.

```{r heatmap_avr, cache=TRUE}
# рассчитываем среднее количество поездок
dt_agg_avr <- dt_agg[, .(avr_n = mean(n)), by = .(region)]
# добавляем границы квадратиков
dt_agg_avr <- cbind(dt_agg_avr, regions[,2:5])


# палитра для квадратиков 
shades <- 50 # 50 оттенков красно-оранжевого
pal_OrRd <- seq(0, 1, length.out = 50) %>% 
    (brewer_pal(palette = 'OrRd', direction = -1)(9)[1:5] %>% 
         rev %>% gradient_n_pal)

# прологарифмируем средние значения и разобьем их на 50 градаций 
# сопоставляем цвет из палитры каждому полученному числу
dt_agg_avr <- dt_agg_avr[, 
    fill_color := pal_OrRd[log(avr_n + 1) %>% cut(breaks = shades) %>%
                               as.numeric()]]

# добавляем признак прозрачности, ~ sqrt(n)
dt_agg_avr <- dt_agg_avr[, alpha := sqrt(avr_n + 1) %>% rescale(c(0.2, 0.6))]

# отрисуем карту
leaflet(dt_agg_avr[avr_n > 0.1], width = '100%') %>% addTiles() %>% 
    # квадратики
    addRectangles(lng1 = ~west, lng2 = ~east, lat = ~south, lat2 = ~north,
                  # границы квадратиков
                  weight = 1, color = 'gray', opacity = 4/10,
                  # заливка квадратиков
                  fillOpacity = ~alpha, fillColor = ~fill_color,
                  # описание квадратика
                  popup = ~paste('region:', region, 'avr_n:', round(avr_n, 1)),
                  # для управления слоями
                  group = 'heatmap') %>%
    # чтобы квадратики можно было убирать
    addLayersControl(
        overlayGroups = c("heatmap"),
        options = layersControlOptions(collapsed = FALSE))
```




### 6. Отфильтруйте ячейки {#w2s6}

*Чтобы не выбирать из всех 2500 ячеек вручную, отфильтруйте ячейки, из которых в мае совершается в среднем меньше 5 поездок в час. Посчитайте количество оставшихся. Проверьте на карте, что среди этих ячеек нет таких, из которых поездки на самом деле невозможны.*

После того, как уберем зоны, откуда было в среднем было меньше 5 поездок в час, останется 102 региона:

```{r filter_regions}
dt_agg_avr[avr_n >= 5, .N]
```

Отобразим и выделим их на карте. Включая и отключая слой с регионами можно убедиться, что из всех этих зон возможны поездки.

```{r regions_102, cache=TRUE}
# отрисуем карту
leaflet(dt_agg_avr[avr_n >= 5], width = '100%') %>% addTiles() %>% 
    # квадратики
    addRectangles(lng1 = ~west, lng2 = ~east, lat = ~south, lat2 = ~north,
                  # границы квадратиков
                  weight = 1, color = 'gray', opacity = 3/4,
                  # заливка квадратиков
                  fillOpacity = 1/2, fillColor = 'maroon',
                  # описание квадратика
                  popup = ~paste('region:', region, 'avr_n:', round(avr_n, 1)),
                  # для управления слоями
                  group = 'heatmap') %>%
    # чтобы квадратики можно было убирать
    addLayersControl(
        overlayGroups = c("heatmap"),
        options = layersControlOptions(collapsed = FALSE))
```



### 7. Опубликуйте ноутбук {#w2s7}

Ноутбук опубликован на [rstudioconnect.com](https://beta.rstudioconnect.com/content/2218/taxi02.html). Файлы проекта также можно найти и на [гитхабе](https://github.com/yurkai/taxi).































